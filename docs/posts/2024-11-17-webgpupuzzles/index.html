<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vishal Bakshi">
<meta name="dcterms.date" content="2024-09-30">
<meta name="description" content="This blog post contains my walkthrough of the official AnswerAI WebGPU Puzzle solutions that I found challenging to understand and/or critical in helping me understand core concepts of GPU programming.">

<title>vishal bakshi - WebGPG Puzzles: Walk through of Official Solutions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">vishal bakshi</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#puzzle-7" id="toc-puzzle-7" class="nav-link" data-scroll-target="#puzzle-7">Puzzle 7</a></li>
  <li><a href="#puzzle-8" id="toc-puzzle-8" class="nav-link" data-scroll-target="#puzzle-8">Puzzle 8</a></li>
  <li><a href="#puzzle-9" id="toc-puzzle-9" class="nav-link" data-scroll-target="#puzzle-9">Puzzle 9</a></li>
  <li><a href="#puzzle-10" id="toc-puzzle-10" class="nav-link" data-scroll-target="#puzzle-10">Puzzle 10</a></li>
  <li><a href="#puzzle-11" id="toc-puzzle-11" class="nav-link" data-scroll-target="#puzzle-11">Puzzle 11</a></li>
  <li><a href="#puzzle-12" id="toc-puzzle-12" class="nav-link" data-scroll-target="#puzzle-12">Puzzle 12</a></li>
  <li><a href="#puzzle-13" id="toc-puzzle-13" class="nav-link" data-scroll-target="#puzzle-13">Puzzle 13</a></li>
  <li><a href="#puzzle-14" id="toc-puzzle-14" class="nav-link" data-scroll-target="#puzzle-14">Puzzle 14</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">WebGPG Puzzles: Walk through of Official Solutions</h1>
  <div class="quarto-categories">
    <div class="quarto-category">python</div>
    <div class="quarto-category">fastai</div>
  </div>
  </div>

<div>
  <div class="description">
    This blog post contains my walkthrough of the official AnswerAI WebGPU Puzzle solutions that I found challenging to understand and/or critical in helping me understand core concepts of GPU programming.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vishal Bakshi </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 30, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>This file contains my walkthrough of the official WebGPU Puzzle solutions that I found challenging to understand and/or critical in helping me understand core concepts of GPU programming. You can find the Excel spreadsheet with my solution visualizations <a href="https://github.com/vishalbakshi/webgpupuzzles/blob/main/webgpupuzzles.xlsx">here</a>. The WebGPU puzzles are published by Answer.AI at https://gpupuzzles.answer.ai/puzzles.</p>
</section>
<section id="puzzle-7" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-7">Puzzle 7</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}}); // workgroup sizes
const twg = vec3({{totalWorkgroups}}); // total workgroups

@compute @workgroup_size({{workgroupSize}})
fn main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
        @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
        @builtin(workgroup_id) wid: vec3&lt;u32&gt;
        ) {

  let wgSize: u32 = wgs.x * wgs.y * wgs.z;
  let wg = wid.x + wid.y * twg.x;
  let i = lid.x + lid.y * wgs.x + wg * wgSize;
  out[i] = a[i] + 10;
}</code></pre>
<pre><code>___________________________________
Test case 1 

Workgroup Size       ( 2, 2, 1 )
Total Workgroups     ( 2, 2, 1 )

Input a  [  0  1  2  3  4  5  6  7  8 ]
Expected [ 10 11 12 13 14 15 16 17 18 ]

___________________________________
Test case 2 

Workgroup Size       ( 2, 2, 1 )
Total Workgroups     ( 3, 3, 1 )

Input a  [  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ]
Expected [ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ]</code></pre>
<p>I actually didn’t quite understand this solution until I revisited it while I was working on Puzzle #14 after I recalled that this solution dealt with situations where the number of threads in a workgroup was less than the number of positions in the input array.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_7.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Visualizing the official solution to puzzle #7 in Excel"><img src="screenshots/solution_7.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing the official solution to puzzle #7 in Excel</figcaption><p></p>
</figure>
</div>
<p>I interpret <code>wg</code> as being the global “workgroup indexer” and <code>i</code> as the global “thread indexer.” In <code>wg</code>, the value of <code>wid.x</code> (0, 1, 2) is incremented by 1 as you go down <code>wid.y</code> by the term <code>wid.y * twg.x</code>. Similarly for <code>i</code>, <code>lid.y * wgs.x</code> increments the index by 1 as you go down <code>lid.y</code> while <code>wg * wgSize</code> increments the <code>i</code> by 4 as you traverse over the <code>wg</code> index of the workgroup. In this way, while no single workgroup can handle all 25 elements of the input array, spreading them out across 9 workgroups make this light work.</p>
</section>
<section id="puzzle-8" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-8">Puzzle 8</h2>
<p>This puzzle also had fewer threads per block than number of elements in the input array.</p>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

// workgroup sizes x, y, z
const wgs = vec3({{workgroupSize}});
// total workgroups x, y, z
const twg = vec3({{totalWorkgroups}}); 
// flat shared memory array
var&lt;workgroup&gt; smem: array&lt;f32, {{smemSize}}&gt;; 

@compute @workgroup_size({{workgroupSize}})
fn main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
        @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
        @builtin(workgroup_id) wid: vec3&lt;u32&gt;) {
  if (gid.x &lt; arrayLength(&amp;a)) {
    smem[lid.x] = a[gid.x];
  }
  workgroupBarrier(); 
  out[gid.x] = smem[lid.x] + 10;
}</code></pre>
<pre><code>___________________________________
Test case 1

Workgroup Size       ( 4, 1, 1 )
Total Workgroups     ( 2, 1, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7 ]

Expected [ 10 11 12 13 14 15 16 17 ]

___________________________________
Test case 2

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 2, 1, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 ]

Expected [ 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ]</code></pre>
<p>The following lines load the input array into shared memory:</p>
<pre class="wgsl"><code>if (gid.x &lt; arrayLength(&amp;a)) {
    smem[lid.x] = a[gid.x];
}</code></pre>
<p>Visualizing Test Case 1: in each workgroup, since <code>lid.x</code> is (0, 1, 2, 3), only the first four elements of shared memory are filled with data. In the first workgroup, <code>gid.x</code> is (0, 1, 2, 3) and in the second workgroup, it’s (4, 5, 6, 7) so the corresponding elements of input array <code>a</code> are loaded into shared memory.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_8_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Visualizing test case 1 for puzzle 8 in Excel"><img src="screenshots/solution_8_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 8 in Excel</figcaption><p></p>
</figure>
</div>
<p>The following line assigns to <code>out</code> in each workgroup the first four elements of <code>smem</code>:</p>
<pre class="wgsl"><code>out[gid.x] = smem[lid.x];</code></pre>
<p>Visualizing that in Excel for Test Case 1:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_8_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Visualizing test case 1 for puzzle 8 in Excel"><img src="screenshots/solution_8_2.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 8 in Excel</figcaption><p></p>
</figure>
</div>
<p><code>lid.x</code> is always (0, 1, 2, 3) so the first four elements of <code>smem</code> are always indexed. <code>gid.x</code> is (0, 1, 2, 3) for <code>wid.x = 0</code> and (4, 5, 6, 7) for <code>wid.x = 1</code> so the first four elements of <code>out</code> are loaded with the first four elements of <code>smem</code> for the first workgroup and the second four elements of <code>out</code> are loaded with the first four elements of <code>smem</code> for the second workgroup. Adding 10 to <code>smem</code> values gives the expected output:</p>
<pre class="wgsl"><code>out[gid.x] = smem[lid.x];</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_8_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Visualizing test case 1 for puzzle 8 in Excel"><img src="screenshots/solution_8_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 8 in Excel</figcaption><p></p>
</figure>
</div>
<p>Here are is the solution visualized for Test Case 2:</p>
<p>The full 8-element shared memory array is filled with values from the 16-element input array <code>a</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_8_4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Visualizing test case 2 for puzzle 8 in Excel"><img src="screenshots/solution_8_4.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 2 for puzzle 8 in Excel</figcaption><p></p>
</figure>
</div>
<p>Again <code>lid.x</code> is equal in both workgroups, so the first 8 elements of <code>smem</code> are loaded into the corresponding sequence of 8 elements in <code>out</code> using <code>gid.x</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_8_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Visualizing test case 2 for puzzle 8 in Excel"><img src="screenshots/solution_8_5.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 2 for puzzle 8 in Excel</figcaption><p></p>
</figure>
</div>
<p>Adding 10 to the <code>smem</code> values yields the expected result:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_8_6.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Visualizing test case 2 for puzzle 8 in Excel"><img src="screenshots/solution_8_6.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 2 for puzzle 8 in Excel</figcaption><p></p>
</figure>
</div>
</section>
<section id="puzzle-9" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-9">Puzzle 9</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}}); // workgroup sizes
const twg = vec3({{totalWorkgroups}}); // total workgroups
var&lt;workgroup&gt; smem: array&lt;f32, {{smemSize}}&gt;;

@compute @workgroup_size({{workgroupSize}})
fn main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
        @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
        @builtin(workgroup_id) wid: vec3&lt;u32&gt;
        ) {
    let i = lid.x + lid.y * wgs.x;
    smem[lid.x] = a[i];
    workgroupBarrier();
    out[lid.x] = smem[lid.x];
    if (lid.x &gt; 0) {
        out[lid.x] += smem[lid.x - 1];
        if (lid.x &gt; 1) {
            out[lid.x] += smem[lid.x - 2];
        }
    }
}</code></pre>
<pre><code>___________________________________
Test case 1

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7 ]
Expected [  0  1  3  6  9 12 15 18 ]

___________________________________
Test case 2

Workgroup Size       ( 10, 1, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 10, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7  8  9 ]
Expected [  0  1  3  6  9 12 15 18 21 24 ]</code></pre>
<p>Since we have only one workgroup with size (8, 1, 1) in Test Case 1, <code>wgs.x</code> is <code>0</code> and <code>lid.y</code> is <code>0</code>, so <code>i</code> ends up being equal to <code>lid.x</code>. The shared memory array <code>smem</code> has the same size as the input array <code>a</code> (and the workgroup) so <code>smem[lid.x] = a[i]</code> loads in the entire array <code>a</code> into shared memory.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_9_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Visualizing test case 1 for puzzle 9 in Excel"><img src="screenshots/solution_9_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 9 in Excel</figcaption><p></p>
</figure>
</div>
<p>Next, we load into <code>out</code> the entire array <code>smem</code> with the following line:</p>
<pre class="wgsl"><code>out[lid.x] = smem[lid.x];</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_9_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Visualizing test case 1 for puzzle 9 in Excel"><img src="screenshots/solution_9_2.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 9 in Excel</figcaption><p></p>
</figure>
</div>
<p>Our goal is to “sum together the last 3 positions of <code>a</code> and store it in <code>out</code>.” To do this, we first “slide” or “shift” <code>smem</code> one element to the right with the code <code>smem[lid.x - 1]</code>, and add it to <code>out</code>. We only do this for <code>i</code> values above <code>0</code> since we don’t want to index into <code>smem</code> with <code>-1</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_9_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Visualizing test case 1 for puzzle 9 in Excel"><img src="screenshots/solution_9_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 9 in Excel</figcaption><p></p>
</figure>
</div>
<p>We shift <code>smem</code> by 2 elements to the right (again only doing it for <code>i</code> values that won’t result in a negative index, <code>i &gt; 1</code>) and add that to <code>out</code> to get our expected result:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_9_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Visualizing test case 1 for puzzle 9 in Excel"><img src="screenshots/solution_9_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 9 in Excel</figcaption><p></p>
</figure>
</div>
</section>
<section id="puzzle-10" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-10">Puzzle 10</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; b : array&lt;f32&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}});
const twg = vec3({{totalWorkgroups}});
var&lt;workgroup&gt; smem: array&lt;f32, {{smemSize}}&gt;;

@compute @workgroup_size({{workgroupSize}})
fn  main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
         @builtin(global_invocation_id) gid: vec3&lt;u32&gt;) {
    
   // assumes wgs.x &gt; arrayLength(&amp;a);
   smem[lid.x]  = a[gid.x] * b[gid.x];
   
   workgroupBarrier();
             
    if (gid.x == 0) {
        for (var i: u32=0; i&lt;arrayLength(&amp;a); i+=1) {
            out[0] += smem[i];
        }
    }
}</code></pre>
<pre><code>___________________________________
Test case 1 

Workgroup Size       ( 4, 1, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 4, 1, 1 )

Input a  [  0  1  2  3 ]
Input b  [  0  1  2  3 ]

Expected [ 14 ]

___________________________________
Test case 2 

Workgroup Size       ( 5, 1, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 5, 1, 1 )

Input a  [  0  1  2  3  4 ]
Input b  [  0  1  2  3  4 ]

Expected [ 30 ]</code></pre>
<p>To take the dot product between two 1-D array, we need to take their cumulative element-wise sum. The official solution starts by loading these element-wise sums into shared memory with:</p>
<pre class="wgsl"><code>smem[lid.x]  = a[gid.x] * b[gid.x];</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_10_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Visualizing test case 1 for puzzle 10 in Excel"><img src="screenshots/solution_10_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 10 in Excel</figcaption><p></p>
</figure>
</div>
<p>After that, we simply iterate through the shared memory array and accumulate the sum with:</p>
<pre class="wgsl"><code>if (gid.x == 0) {
    for (var i: u32=0; i&lt;arrayLength(&amp;a); i+=1) {
        out[0] += smem[i];
    }
}</code></pre>
<p>IIUC, the guard <code>if (gid.x == 0)</code> prevents more than one thread from working on this task.</p>
</section>
<section id="puzzle-11" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-11">Puzzle 11</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; b : array&lt;f32&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}});
const twg = vec3({{totalWorkgroups}});

var&lt;workgroup&gt; smemA: array&lt;f32, wgs.x * wgs.y * wgs.z + 4&gt;;
var&lt;workgroup&gt; smemB: array&lt;f32, 4&gt;;

@compute @workgroup_size({{workgroupSize}})
fn  main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
         @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
         @builtin(workgroup_id) wid: vec3&lt;u32&gt;
         ) {
    // Each workgroup is responsible computes total workgroup size
    // values of out and caches total workgroup size + 4 values
    // of a
    let wgSize: u32 = wgs.x; // assumes wgs.y = wgs.z = 1
    smemA[lid.x] = a[gid.x];
    if (lid.x &lt; 4) {
        smemB[lid.x] = b[lid.x];
        if (wid.x * wgSize + wgSize + lid.x &lt; arrayLength(&amp;a)) {
            smemA[wgSize + lid.x] = 
                a[wid.x * wgSize + wgSize + lid.x];
        } else {
            smemA[wgSize + lid.x] = 0.0;
        }
    }
    workgroupBarrier();
    var sum: f32 = 0.0;
    for (var i: u32 = 0; i &lt; 4; i += 1) {
        if (gid.x + i &lt; arrayLength(&amp;a)) {
            sum = sum + smemA[lid.x + i] * smemB[i];
        }
    }
    out[gid.x] = sum;
}</code></pre>
<pre><code>___________________________________
Test case 1

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 2, 1, 1 )
Shared Memory  Size  ( 12, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 ]
Input b  [  0  1  2  3 ]

Expected [ 14 20 26 32 38 44 50 56 62 68 74 80 41 14  0 ]

___________________________________
Test case 2

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 3, 1, 1 )
Shared Memory  Size  ( 12, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 ]
Input b  [  0  1  2  3 ]

Expected [ 14 20 26 32 38 44 50 56 62 68 74 80 86 92 98 50 17  0 ]</code></pre>
<p>In Test case 1, our workgroup has 8 threads, our shared memory arrays have 12 spots, and our input has 15 elements. We start by loading the first 8 elements of <code>a</code> into <code>smemA</code> with <code>lid.x</code> and <code>gid.x</code>:</p>
<pre class="wgsl"><code>smemA[lid.x] = a[gid.x];</code></pre>
<p>Here’s what that looks like in Excel. Each workgroup gets assigned its consecutive sequence of 8 elements:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>Next, to load in the remaining 4 elements of <code>a</code> into <code>smemA</code> and all four elements of <code>b</code> into <code>smemB</code> we run the following code:</p>
<pre class="wgsl"><code>if (lid.x &lt; 4) {
    smemB[lid.x] = b[lid.x];
    if (wid.x * wgSize + wgSize + lid.x &lt; arrayLength(&amp;a)) {
        smemA[wgSize + lid.x] = a[wid.x * wgSize + wgSize + lid.x];
    } else {
        smemA[wgSize + lid.x] = 0.0;
    }
}</code></pre>
<p>The guard <code>lid.x &lt; 4</code> ensures that we are only handling 4 elements at a time. The next line is simple, and loads the full contents of <code>b</code> into <code>smemB</code>:</p>
<pre class="wgsl"><code>smemB[lid.x] = b[lid.x];</code></pre>
<p>Now we get into some more tricky stuff to assign the correct set of 4 final elements to shared memory in the appropriate workgroup. Let’s first visulize the more involved index (where <code>wgSize</code> is <code>wgs.x</code> which is <code>8</code> in Test case 1):</p>
<pre class="wgsl"><code>wid.x * wgSize + wgSize + lid.x</code></pre>
<p>Visualizing this index in Excel for each workgroup, noting that it’s restricted to 4 elements (due to our guard <code>lid.x &lt; 4</code>) as it builds off <code>lid.x</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_2.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>The other index that we use is <code>wgSize + lid.x</code> which is more straightforward (it adds <code>8</code> to each of the four elements of <code>lid.x</code>):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>This index will be used to <em>extend</em> the index into the lat 4 elements of shared memory array past the <code>8</code> elements available in <code>lid.x</code> or <code>gid.x</code> for each workgroup with the following code:</p>
<pre class="wgsl"><code>if (wid.x * wgSize + wgSize + lid.x &lt; arrayLength(&amp;a)) {
    smemA[wgSize + lid.x] = a[wid.x * wgSize + wgSize + lid.x];
} else {
    smemA[wgSize + lid.x] = 0.0;
}</code></pre>
<p>For the first workgroup, the maximum value of <code>wid.x * wgSize + wgSize + lid.x</code> is less than <code>arrayLength(&amp;a)</code> so we load in the 9th to 12th elements of <code>a</code> into <code>smemA</code>. For the second workgroup, the maximum value of <code>wid.x * wgSize + wgSize + lid.x</code> is more than <code>arrayLength(&amp;a)</code> so we assign 0s:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-16" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_4.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>In this way, we have assigned a maximum of 12 elements of <code>a</code> into <code>smemA</code>, <em>extending</em> the available indexes <code>gid.x</code> and <code>lid.x</code> past their maximum of 8 elements using <code>wid.x</code> and <code>wgs.x</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-17" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_5.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>With our data loaded into shared memory arrays we can now go about performing 1-D convolution between <code>a</code> and <code>b</code> with the following code:</p>
<pre class="wgsl"><code>var sum: f32 = 0.0;
for (var i: u32 = 0; i &lt; 4; i += 1) {
    if (gid.x + i &lt; arrayLength(&amp;a)) {
        sum = sum + smemA[lid.x + i] * smemB[i];
    }
}
out[gid.x] = sum;</code></pre>
<p>Understanding this loop was a pivotal point in my understanding of parallelism. While we are iterating over <code>i</code> which is a 32-bit unsigned integer, we are performing 8 element-wise operations in each loop iteration at the same time (since we are using <code>lid.x</code> to index into <code>smemA</code>) in each workgroup (which is why we use <code>gid.x</code> to index into <code>out</code> to assign the correct value of <code>sum</code>).</p>
<p>What’s counterintuitive at first is that <code>sum</code> is a single <code>f32</code> 32-bit floating point number, but since we are using <code>lid.x</code> and <code>gid.x</code> it is being manipulated 16 different ways (8 threads across 2 workgroups). So although to me it initially <em>looked</em> like <code>sum</code> was behaving as an array, it’s not. The array-like behavior is the parallelism of the GPU.</p>
<p>The following line:</p>
<pre class="wgsl"><code>sum = sum + smemA[lid.x + i] * smemB[i];</code></pre>
<p>is visualized in Excel for the first workgroup as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_6.png" class="lightbox" data-gallery="quarto-lightbox-gallery-18" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_6.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>Note that in each iteration of the loop we are shifting <code>smemA</code> and <code>smemB</code> by 1 element to the left and taking the elementwise product (across 8 threads). From the individual thread’s perspective, it’s a product between two numbers, accumulating their sum over each loop iteration.</p>
<p>Here’s a visualization of the loop iterations in the second workgroup:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_7.png" class="lightbox" data-gallery="quarto-lightbox-gallery-19" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_7.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
<p>After each loop is finished, we assign the resulting number to its corresponding location in <code>out</code> to get our final result:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_11_8.png" class="lightbox" data-gallery="quarto-lightbox-gallery-20" title="Visualizing test case 1 for puzzle 11 in Excel"><img src="screenshots/solution_11_8.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing test case 1 for puzzle 11 in Excel</figcaption><p></p>
</figure>
</div>
</section>
<section id="puzzle-12" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-12">Puzzle 12</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}});
const twg = vec3({{totalWorkgroups}});
var&lt;workgroup&gt; smem: array&lt;f32, {{smemSize}}&gt;;

@compute @workgroup_size({{workgroupSize}})
fn main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
        @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
        @builtin(workgroup_id) wid: vec3&lt;u32&gt;) {
    smem[lid.x] = a[gid.x];
    workgroupBarrier();
    for (var skip: u32 = 1; skip &lt; wgs.x; skip = skip * 2) {
        if (lid.x % skip == 0 
            &amp;&amp; lid.x + skip &lt; wgs.x 
            &amp;&amp; gid.x + skip &lt; arrayLength(&amp;a)) {
            smem[lid.x] = smem[lid.x] + smem[lid.x + skip];
        }
        workgroupBarrier();
    }
    if (lid.x == 0) {
        out[wid.x] = smem[0];
    }
}</code></pre>
<pre><code>___________________________________
Test case 1

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7 ]
Expected [ 28 ]

___________________________________
Test case 2

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 2, 1, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  [  0  1  2  3  4  5  6  7  8  9 ]
Expected [ 28 17 ]</code></pre>
<p>In this puzzle we want to take the block-wise cumulative sum. For Test case 1, there is only 1 block (workgroup) so we want the sum of the full array, which is <code>28</code>. For Test case 2, we have two 8-thread blocks and a 10-element input array. The cumulative sum for the first block is the sum of the first 8 elements (<code>28</code>) and the cumulative sum for the second block is the sum of the next two elements (<code>17</code>).</p>
<p>The first line of the solution is simple: we want to load into shared memory the corresponding set of 8-elements from the input array:</p>
<pre class="wgsl"><code>smem[lid.x] = a[gid.x];</code></pre>
<p>Visualizing this in Excel for each workgroup:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_12_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-21" title="Visualizing puzzle 12 in Excel"><img src="screenshots/solution_12_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 12 in Excel</figcaption><p></p>
</figure>
</div>
<p>The next chunk of code is quite involved—its goal is to find the cumulative sum of the elements stored in shared memory following certain guards:</p>
<pre class="wgsl"><code>for (var skip: u32 = 1; skip &lt; wgs.x; skip = skip * 2) {
    if (lid.x % skip == 0 
        &amp;&amp; lid.x + skip &lt; wgs.x 
        &amp;&amp; gid.x + skip &lt; arrayLength(&amp;a)) {
        smem[lid.x] = smem[lid.x] + smem[lid.x + skip];
    }
    workgroupBarrier();
}</code></pre>
<p>Here’s what that code looks visualized in Excel where each column of arrays corresponds to each iteration of the loop. The cells highlighted in green in each array are the elements which pass the guard conditions in the <code>if</code>-statement:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_12_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-22" title="Visualizing puzzle 12 in Excel"><img src="screenshots/solution_12_2.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 12 in Excel</figcaption><p></p>
</figure>
</div>
<p>For <code>skip</code> = 1, the first six elements pass the guard conditions. In each case (<code>lid.x</code> of 0, 1, 2, 3, 4, 5), <code>lid.x % skip == 0</code> is true, <code>lid.x + skip &lt; wgs.x</code> is true, and <code>gid.x + skip &lt; arrayLength(&amp;a)</code> is true. For the seventh element (<code>lid.x = 7</code>):</p>
<ul>
<li><code>lid.x % skip == 0</code>: <code>7 % 1 == 0</code> is true</li>
<li><code>lid.x + skip &lt; wgs.x</code>: <code>7 + 1 &lt; 8</code> is false</li>
<li><code>gid.x + skip &lt; arrayLength(&amp;a)</code>: <code>7 + 1 &lt; 8</code> is false</li>
</ul>
<p>For <code>skip</code> = 2: only the 0th, 2nd and 4th element pass the guard conditions. While the 6th element does pass the first guard (<code>lid.x % skip == 0</code>: <code>6 % 2 == 0</code> is true) it fails the second two guards as <code>6 + 2</code> is not less than <code>wgs.x</code> or <code>arrayLength(&amp;a)</code>.</p>
<p>Finally for <code>skip</code> = 4, only the 0th element passes all guard conditions. The 4th element does pass the first condition (<code>lid.x % skip == 0</code>: <code>4 % 4 == 0</code> is true) but fails the second two guards as <code>4 + 4</code> is not less than <code>wgs.x</code> or <code>arrayLength(&amp;a)</code>.</p>
<p>For each <code>skip</code> we slide the elements over by <code>skip</code> and sum them to the previous iteration’s <code>smem</code>.</p>
<p>In Test case 2, we have the same prefix sum (<code>28</code>) for the first block. We also have a second block for which the prefix sum is much simpler since the <code>skip</code> value in only one iteration of the for loop passes all guard conditions.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_12_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-23" title="Visualizing puzzle 12 in Excel"><img src="screenshots/solution_12_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 12 in Excel</figcaption><p></p>
</figure>
</div>
<p>For <code>skip</code> = 1:</p>
<ul>
<li><code>lid.x % skip == 0</code>: is true for all 7 elements.</li>
<li><code>lid.x + skip &lt; wgs.x</code>: is true for all 7 elements.</li>
<li><code>gid.x + skip &lt; arrayLength(&amp;a)</code>: <code>8 + 1 &lt; 10</code> is true <strong>only for the first element</strong>, so that’s the only sum that takes place (8 + 9 = 17).</li>
</ul>
<p>For <code>skip</code> = 2 and <code>skip</code> = 4:</p>
<ul>
<li><code>lid.x % skip == 0</code>: is true for some elements.</li>
<li><code>lid.x + skip &lt; wgs.x</code>: is true for some elements.</li>
<li><code>gid.x + skip &lt; arrayLength(&amp;a)</code>: is true <strong>for no element</strong>, therefore the code inside the if-condition never runs.</li>
</ul>
<p>Understanding the prefix sum algorithm took an unreasonable amount of time for me, and I’m still not completely comfortable, but the following visual did help solidify for me how it works. Green-highlighted cells are pairwise sums corresponding to the given <code>skip</code>. At the bottom I’ve listed out within which pairwise sums the given original array element is included.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_12_4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-24" title="Visualizing puzzle 12 in Excel"><img src="screenshots/solution_12_4.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 12 in Excel</figcaption><p></p>
</figure>
</div>
</section>
<section id="puzzle-13" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-13">Puzzle 13</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a : array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; out : array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}});
const twg = vec3({{totalWorkgroups}});
var&lt;workgroup&gt; smem: array&lt;f32, {{smemSize}}&gt;;

const nRows = 4;

@compute @workgroup_size({{workgroupSize}})
fn main(@builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
        @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
        @builtin(workgroup_id) wid: vec3&lt;u32&gt;) {
    let nCols = arrayLength(&amp;a) / nRows;
    smem[lid.x] = a[wid.y * nCols + lid.x];
    workgroupBarrier();
    for (var skip: u32 = 1; lid.x + skip &lt; nCols; skip *= 2) {
        smem[lid.x] += smem[lid.x+skip];
    }
    
    if (lid.x % nCols == 0) {
        out[wid.y] = smem[0];
    }
}</code></pre>
<pre><code>___________________________________
Test case 1

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 1, 4, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  
        0    1    2    3    4    5  
        6    7    8    9   10   11  
       12   13   14   15   16   17  
       18   19   20   21   22   23

Expected [ 15 51 87 123 ]

___________________________________
Test case 2

Workgroup Size       ( 8, 1, 1 )
Total Workgroups     ( 1, 4, 1 )
Shared Memory  Size  ( 8, 1, 1 )

Input a  
        0    1    2    3  
        4    5    6    7  
        8    9   10   11  
       12   13   14   15

Expected [  6 22 38 54 ]</code></pre>
<p>The goal of this exercise is to find the sum of each “row” in the input array. I put “row” in quotation marks because the input array is actually 1-D, so we look at the example to determine how many rows and columns we want.</p>
<p>I’ll walk through Test case 1.</p>
<p>The number of rows is a constant 4:</p>
<pre class="wgsl"><code>const nRows = 4;</code></pre>
<p>The number of columns is the length of the array divided by the number of rows:</p>
<pre class="wgsl"><code>let nCols = arrayLength(&amp;a) / nRows;</code></pre>
<p>Each row of the input array is stored in a separate workgroup’s shared memory. This is achieved by multiplying <code>nCols</code> by <code>wid.y</code> before adding <code>lid.x</code>:</p>
<pre class="wgsl"><code>smem[lid.x] = a[wid.y * nCols + lid.x];</code></pre>
<p>Here’s what that index, <code>wid.y * nCols + lid.x</code>, looks like for each row:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"><code>wid.y</code></th>
<th style="text-align: center;"><code>wid.y * nCols + lid.x</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;"><code>0, 1, 2, 3, 4, 5</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;"><code>6, 7, 8, 9, 10, 11</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>2</code></td>
<td style="text-align: center;"><code>12, 13, 14, 15, 16, 17</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>3</code></td>
<td style="text-align: center;"><code>18, 19, 20, 21, 22, 23</code></td>
</tr>
</tbody>
</table>
<p>Visualizing how, using the index <code>wid.y * nCols + lid.x</code>, we load the input array <code>a</code> into each workgroup’s shared memory <code>smem</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_13_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-25" title="Visualizing puzzle 13 in Excel"><img src="screenshots/solution_13_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 13 in Excel</figcaption><p></p>
</figure>
</div>
<p>Next, similar to the previous puzzle’s prefix sum algorithm, we iterate through each row, accumulating the sum by iterating over array elements in increasing <code>skip</code> amounts:</p>
<pre class="wgsl"><code>for (var skip: u32 = 1; lid.x + skip &lt; nCols; skip *= 2) {
    smem[lid.x] += smem[lid.x+skip];
}</code></pre>
<p>Visualizing that for-loop in the first workgroup, in which we find the sum of the first row of <code>a</code> (highlighted in green):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_13_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-26" title="Visualizing puzzle 13 in Excel"><img src="screenshots/solution_13_2.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 13 in Excel</figcaption><p></p>
</figure>
</div>
<p>I’m not 100% sure why we don’t have guards in this puzzle as we did in Puzzle 12, but my guess is that we don’t need it here since the number of threads in the workgroup (8) is the same as the shared memory size (8).</p>
<p>Visualizing the for-loops that occur in the other three workgroups, one for each row of the input array with the final cumulative sum highlighted in green:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_13_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-27" title="Visualizing puzzle 13 in Excel"><img src="screenshots/solution_13_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 13 in Excel</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_13_4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-28" title="Visualizing puzzle 13 in Excel"><img src="screenshots/solution_13_4.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 13 in Excel</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_13_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-29" title="Visualizing puzzle 13 in Excel"><img src="screenshots/solution_13_5.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 13 in Excel</figcaption><p></p>
</figure>
</div>
</section>
<section id="puzzle-14" class="level2">
<h2 class="anchored" data-anchor-id="puzzle-14">Puzzle 14</h2>
<pre class="wgsl"><code>@group(0) @binding(0) var&lt;storage, read_write&gt; a: array&lt;f32&gt;;
@group(0) @binding(1) var&lt;storage, read_write&gt; b: array&lt;f32&gt;;
@group(0) @binding(2) var&lt;storage, read_write&gt; output: array&lt;f32&gt;;

const wgs = vec3({{workgroupSize}});
const twg = vec3({{totalWorkgroups}});
const tileSize = vec3({{workgroupSize}});
var&lt;workgroup&gt; a_shared: array&lt;f32, 256&gt;;
var&lt;workgroup&gt; b_shared: array&lt;f32, 256&gt;;

@compute @workgroup_size({{workgroupSize}})
fn main(
  @builtin(local_invocation_id) lid: vec3&lt;u32&gt;,
  @builtin(global_invocation_id) gid: vec3&lt;u32&gt;,
  @builtin(workgroup_id) wid: vec3&lt;u32&gt;) {
    let N = u32(sqrt(f32(arrayLength(&amp;a))));
    let i = wid.x * wgs.x + lid.x;
    let j = wid.y * wgs.y + lid.y;
    let local_i = lid.x;
    let local_j = lid.y;

    var acc: f32 = 0.0;

    for (var k: u32 = 0u; k &lt; N; k = k + tileSize.x) {
      if (j &lt; N &amp;&amp; k + local_i &lt; N) {
        a_shared[local_j * tileSize.x + local_i] 
        = a[j * N + (k + local_i)];
      } else {
        a_shared[local_j * tileSize.x + local_i] = 0.0;
      }
      if (i &lt; N &amp;&amp; k + local_j &lt; N) {
        b_shared[local_j * tileSize.x + local_i] 
        = b[i + (k + local_j) * N];
      } else {
        b_shared[local_j * tileSize.x + local_i] = 0.0;
      }

      workgroupBarrier();

      let local_k_max = min(tileSize.x, N - k);
      for (var local_k: u32 = 0u; 
            local_k &lt; local_k_max; 
            local_k = local_k + 1u) {
        acc += a_shared[local_j * tileSize.x + local_k] 
          * b_shared[local_k * tileSize.x + local_i];
      }

      workgroupBarrier();
    }

    if (i &lt; N &amp;&amp; j &lt; N) {
      output[i + j * N] = acc;
    }
}</code></pre>
<pre><code>___________________________________
Test case 1

Workgroup Size       ( 3, 3, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 3, 3, 1 )

Input a  
        0    1  
        2    3

Input b  
        0    1  
        2    3

Expected 
        2    3  
        6   11

___________________________________
Test case 2

Workgroup Size       ( 1, 1, 1 )
Total Workgroups     ( 2, 2, 1 )
Shared Memory  Size  ( 3, 3, 1 )

Input a  
        0    1  
        2    3

Input b  
        0    1  
        2    3

Expected 
        2    3  
        6   11

___________________________________
Test case 3

Workgroup Size       ( 4, 4, 1 )
Total Workgroups     ( 1, 1, 1 )
Shared Memory  Size  ( 4, 4, 1 )

Input a  
        0    1    2  
        3    4    5  
        6    7    8

Input b  
        9   10   11  
       12   13   14  
       15   16   17

Expected 
       42   45   48  
      150  162  174  
      258  279  300

___________________________________
Test case 4

Workgroup Size       ( 2, 2, 1 )
Total Workgroups     ( 2, 2, 1 )
Shared Memory  Size  ( 2, 2, 1 )

Input a  
        0    1    2  
        3    4    5  
        6    7    8

Input b  
        9   10   11  
       12   13   14  
       15   16   17

Expected 
       42   45   48  
      150  162  174  
      258  279  300

___________________________________
Test case 5

Workgroup Size       ( 2, 2, 1 )
Total Workgroups     ( 2, 2, 1 )
Shared Memory  Size  ( 2, 2, 1 )

Input a  
        0    1    2    3  
        4    5    6    7  
        8    9   10   11  
       12   13   14   15

Input b  
        0    1    2    3  
        4    5    6    7  
        8    9   10   11  
       12   13   14   15

Expected 
       56   62   68   74  
      152  174  196  218  
      248  286  324  362  
      344  398  452  506</code></pre>
<p>Walking through this puzzle’s official solution was another pivotal point in my understanding of GPU parallelism. I’ll start with Test case 1.</p>
<p>There are three, what I call, “core indexes” that this solution establishes: <code>local_i</code>, <code>local_j</code> and <code>local_j * tileSize.x + local_i</code>. We can see that <code>local_i</code> indexes across rows while <code>local_j</code> indexes down columns. <code>local_j * tileSize.x + local_i</code> indexes the threads left-to-right and top-to-bottom.</p>
<pre class="wgsl"><code>let N = u32(sqrt(f32(arrayLength(&amp;a))));
let i = wid.x * wgs.x + lid.x;
let j = wid.y * wgs.y + lid.y;
let local_i = lid.x;
let local_j = lid.y;</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-30" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_1.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>The indexes <code>i</code> and <code>j</code> (which we’ll look at shortly), because we have only 1 workgroup for Test case 1, are the same as <code>local_i</code> and <code>local_j</code>, respectively.</p>
<p>Let’s next tackle the code which loads input arrays <code>a</code> and <code>b</code> into shared memory <code>a_shared</code> and <code>b_shared</code>, respectively:</p>
<pre class="wgsl"><code>if (j &lt; N &amp;&amp; k + local_i &lt; N) {
    a_shared[local_j * tileSize.x + local_i] = a[j * N + (k + local_i)];
} else {
    a_shared[local_j * tileSize.x + local_i] = 0.0;
}

if (i &lt; N &amp;&amp; k + local_j &lt; N) {
    b_shared[local_j * tileSize.x + local_i] = b[i + (k + local_j) * N];
} else {
    b_shared[local_j * tileSize.x + local_i] = 0.0;
}</code></pre>
<p>Note that this code runs inside a for-loop:</p>
<pre class="wgsl"><code>for (var k: u32 = 0u; k &lt; N; k = k + tileSize.x) { ... }</code></pre>
<p>but since <code>N</code> is <code>2</code> and <code>tileSize.x</code> is <code>3</code> for this test case this outermost loop runs only once.</p>
<p>The visualization below is, at the highest level, broken into two boxes: one for <code>a_shared</code> (left) and one for <code>b_shared</code> (right).</p>
<pre class="wgsl"><code>if (j &lt; N &amp;&amp; k + local_i &lt; N) {
    a_shared[local_j * tileSize.x + local_i] = a[j * N + (k + local_i)];
} else {
    a_shared[local_j * tileSize.x + local_i] = 0.0;
}</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-31" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_2.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Let’s walk through <code>a_shared</code> first.</p>
<p>The cells highlighted in green are the threads that satisfy the guard condition <code>j &lt; N</code>. In this single iteration of the outermost loop, <code>k = 0</code>. The second condition in the guard is <code>k + local_i &lt; N</code>, the threads in the workgroup which satisfy this condition are highlighted in green. When combining the use of indexes <code>j</code> and <code>k + local_i</code> we see that the threads which satisfy the full condition <code>j &lt; N &amp;&amp; k + local_i &lt; N</code> are highlighted in green. There are four such threads and they are indexed 0, 1, 2, 3—these are used to index into <code>a</code> when assigning values to <code>a_shared</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-32" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_3.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>The grid on the right shows the values of <code>a</code> that are assigned to <code>a_shared</code> at the indexes in the grid shown on the left:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-33" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_4.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Here’s a mapping of index to value for <code>a_shared</code>—this is key in understanding the next part of the code:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Index</th>
<th style="text-align: center;">Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<p>We can now go into the inner-most loop:</p>
<pre class="wgsl"><code>let local_k_max = min(tileSize.x, N - k);
for (
        var local_k: u32 = 0u; 
        local_k &lt; local_k_max; 
        local_k = local_k + 1u
    ) {
        acc += a_shared[local_j * tileSize.x + local_k] * b_shared[local_k * tileSize.x + local_i];
}</code></pre>
<p><code>local_k_max</code> is <code>2</code> (<code>N - k</code>), so the loop iterates twice, as shown in the visualization below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-34" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_5.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Going left-to-right in each loop iterations:</p>
<ul>
<li><code>local_j * tileSize.x + local_k</code>: the index into <code>a_shared</code>.</li>
<li><code>local_k * tileSize.x + local_i</code>: the index into <code>b_shared</code>.</li>
<li><code>a_shared[local_j * tileSize.x + local_k]</code>: the values of <code>a_shared</code> used in the loop iteration.</li>
<li><code>b_shared[local_k * tileSize.x + local_i]</code>: the values of <code>b_shared</code> used in the loop iteration.</li>
<li><code>acc</code>: the element-wise product of <code>a_shared[local_j * tileSize.x + local_k]</code> and <code>b_shared[local_k * tileSize.x + local_i]</code>.</li>
</ul>
<p>Note that while <code>acc</code> looks like an array, it’s actually just a single floating point value (<code>var acc: f32 = 0.0;</code>) which has a different value in each workgroup thread. That is the power of indexing!</p>
<p>Looking at the matrix multiplication between <code>a</code> and <code>b</code> as we would do it by hand:</p>
<p><span class="math display">\[\left[\begin{matrix}0 &amp; 1 \ 2 &amp; 3\end{matrix}\right] \times \left[\begin{matrix}0 &amp; 1 \ 2 &amp; 3\end{matrix}\right] = \left[\begin{matrix}2 &amp; 3 \ 6 &amp; 11\end{matrix}\right]\]</span></p>
<p>The top-left value in the result (2) is the dot product between the first row of <code>a</code> and the first column of <code>b</code>. In our GPU-implementation, that dot product occurs across two loop iterations and different threads as shown in the purple-highlighted cells below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_6.png" class="lightbox" data-gallery="quarto-lightbox-gallery-35" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_6.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Let’s now take a look at test case 2.</p>
<p>Here are the constants and “core indexes” for this test case (same code, different organization than test case 1).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_7.png" class="lightbox" data-gallery="quarto-lightbox-gallery-36" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_7.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>For this test case, the outermost loop runs twice and each time the innermost loop runs once. Here’s the first iteration of the outermost loop:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_8.png" class="lightbox" data-gallery="quarto-lightbox-gallery-37" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_8.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>and here’s the second iteration of the outermost loop (with its single iteration of the innermost loop):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_9.png" class="lightbox" data-gallery="quarto-lightbox-gallery-38" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_9.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Note that the value of <code>acc</code> at the end of each outermost loop iteration is the same as test case 1 except that now, since we have 4 workgroups each with 1 thread, each value of the four values of <code>acc</code> in test case 2 are assigned to one workgroup each.</p>
<p>Let’s move on to test case 3, in which we now are performing matrix multiplication between two 3x3 matrices in a single workgroup, analogous to test case 1.</p>
<p>The constants and core indexes:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_10.png" class="lightbox" data-gallery="quarto-lightbox-gallery-39" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_10.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>The outermost loop, for this test case, runs only once. Here are the indexes used and values of <code>a_shared</code> and <code>b_shared</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_11.png" class="lightbox" data-gallery="quarto-lightbox-gallery-40" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_11.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p><code>local_k_max</code> is <code>3</code> so the innermost loop runs three times, with the final result highlighted in green:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_12.png" class="lightbox" data-gallery="quarto-lightbox-gallery-41" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_12.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Moving on to test case 4, which is unique so far in the sense that the number of threads per workgroup (2x2 = 4) is less than the number of elements in each matrix being multiplied (3x3 = 9). However, the core indexes and inner- and outermost loops still suffice.</p>
<p>The constants and core indexes:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_13.png" class="lightbox" data-gallery="quarto-lightbox-gallery-42" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_13.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>The outermost loop has two iterations. Here is the first iteration, in which the innermost loop runs twice:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_14.png" class="lightbox" data-gallery="quarto-lightbox-gallery-43" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_14.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>In the second-most iteration of the outermost loop, the innermost loop runs only once, note the final result highlighted in green:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_15.png" class="lightbox" data-gallery="quarto-lightbox-gallery-44" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_15.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Here’s a visualization of how the dot product of the first row of <code>a</code> (0, 1, 2) and the first column of <code>b</code> (9, 12, 15) accumulates through element-wise products across different loop iterations to yield the final result of <code>42</code>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_16.png" class="lightbox" data-gallery="quarto-lightbox-gallery-45" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_16.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>The last test case is test case 5, in which the number of available threads (16) matches the number of elements in each input array (16).</p>
<p>The constants and core indexes:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_17.png" class="lightbox" data-gallery="quarto-lightbox-gallery-46" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_17.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>The outermost loop runs twice and each time the innermost loop runs twice as well. Here’s the first iteration of the outermost loop:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_18.png" class="lightbox" data-gallery="quarto-lightbox-gallery-47" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_18.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Here is the second iteration of the outermost loop (the inner loop runs twice). Note the final result highlighted in green, uses up all threads:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_19.png" class="lightbox" data-gallery="quarto-lightbox-gallery-48" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_19.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>Here I visualize the dot product between the first row of <code>a</code> (0, 1, 2, 3) and the first column of <code>b</code> (0, 4, 8, 12) to yield the result <code>56</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="screenshots/solution_14_20.png" class="lightbox" data-gallery="quarto-lightbox-gallery-49" title="Visualizing puzzle 14 in Excel"><img src="screenshots/solution_14_20.png" class="img-fluid figure-img"></a></p>
<p></p><figcaption class="figure-caption">Visualizing puzzle 14 in Excel</figcaption><p></p>
</figure>
</div>
<p>That’s a wrap for the official solutions’ walk through! You can find the Excel spreadsheet <a href="https://github.com/vishalbakshi/webgpupuzzles/blob/main/webgpupuzzles.xlsx">here</a>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","descPosition":"bottom","openEffect":"zoom","loop":true,"closeEffect":"zoom"});</script>



</body></html>